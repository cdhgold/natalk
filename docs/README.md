# 📱 나만의 톡 (NaTalk : 나톡) 기획서 v1.0

> **"우리만의 대화, 그 이상의 폐쇄성"** > 불특정 다수와의 연결이 아닌, 허락된 소수(10명 미만)만을 위한 극비 대화 공간입니다.

---

## 1. 서비스 핵심 가치 (USP)
- **Extreme Privacy**: 방장의 초대와 암호 승인 없이는 존재조차 알 수 없는 비밀 공간.
- **Direct Access**: 앱 실행 시 리스트를 거치지 않고 즉시 대화창으로 진입하는 속도감.
- **Zero Exposure**: 내가 속한 방 외에 다른 방은 검색도, 접근도 불가능한 완전 격리 구조.

## 2. 주요 기능 및 프로세스

### ① 방장의 초대 및 입장 (Gatekeeping)
- **초대 방식**: 방장이 생성한 고유 초대 코드(Unique ID) 공유.
- **2단계 승인**: 초대 코드로 접속 후, 방장이 설정한 '방 비밀번호'를 입력해야 최종 입장 가능.
- **10인 제한**: 서버 부하를 최소화하고 프라이빗한 느낌을 유지하기 위해 최대 인원 10명 고정.

### ② 앱 진입 시나리오 (UX Flow)
- **Auto-Landing**: 로그인/입장 정보가 브라우저(또는 PWA)에 저장되어 있다면, 앱 아이콘 클릭 시 바로 대화창으로 이동.
- **Single Room View**: 사용자는 오직 자신이 참여한 '그 방' 하나만 볼 수 있음. (방 목록 인터페이스 생략)

### ③ 대화 및 보안 (Security)
- **격리된 저장소**: 데이터베이스 설계 시 `RoomID`를 기반으로 데이터를 완전히 분리하여 다른 방의 데이터가 섞일 가능성 차단.
- **휘발성 메시지 (보안 옵션)**: 일정 시간이 지나면 메시지가 서버에서 자동 삭제되는 기능(추후 검토).

## 3. 기술 스택 (추천)
- **Frontend**: React + Tailwind CSS (이미 구축된 UI 시스템 활용)
- **Backend**: Node.js + Express (기존 서버 활용)
- **Real-time**: Socket.io (실시간 양방향 통신 구현)
- **Database**: `posts.json`과 유사한 구조의 `chats.json` 또는 가벼운 SQLite.
- **Deployment**: 네이버 클라우드 Docker 컨테이너 (Port: 3002)

## 4. 카카오톡과의 차별화 포인트
| 기능 | 카카오톡 | 나톡 (NaTalk) |
| :--- | :--- | :--- |
| **접근성** | 누구나 친구 추가 가능 | 방장의 코드와 암호 필수 |
| **첫 화면** | 친구 목록 / 광고 / 오픈채팅 | **바로 대화창 (Quick-In)** |
| **방 탐색** | 오픈채팅 검색 가능 | **검색 불가 (Ghost Room)** |
| **인원** | 수천 명 참여 가능 | **10명 미만 소규모 집중** |

---

## 5. 단계별 개발 로드맵
- **1단계 (MVP)**: Socket.io를 이용한 기본적인 실시간 채팅 기능 구현.
- **2단계 (Security)**: 방 입장 시 암호 확인 로직 및 `localStorage`를 이용한 자동 입장 구현.
- **3단계 (PWA)**: 홈 화면에 추가하여 진짜 앱처럼 전체 화면으로 대화창 진입.

파일 저장 방식: JSON 파일로 채팅 내용을 저장하신다면, chats.json 파일 안에 roomId를 키값으로 사용하세요. 10명 미만이면 성능 저하 없이 충분히 운영 가능합니다.하루가 지나면 파일삭제. 대화방별로 파일생성한다.

보완할 점: 방장이 사용자를 '강퇴'하거나 '방을 폭파'하는 기능포함

## 6. 아래와 같은 구조
Natalk/
├── docs/           <-- 방금 만든 기획서(NaTalk.md) 배치
├── server/         <-- Express + Socket.io (Back-end)
│   ├── data/       <-- chats.json 저장소( 방이름으로 저장)
│   └── index.js
├── client/         <-- React + Vite + Tailwind (Front-end)
├── Dockerfile
└── .dockerignore

## 6 '나톡'의 핵심 기능 구현 로직 (방장 초대 & 자동 입장)
기획서에 적어주신 "앱을 켜면 바로 대화창 이동" 기능을 위해 구현해야 할 핵심 기술입니다.

방장 초대 로직: 방장이 고유한 roomToken을 생성하고, 서버는 이 토큰을 아는 사람만 소켓 연결을 허용합니다.

LocalStorage 활용: 한 번 암호를 맞게 입력하고 입장하면, 브라우저의 localStorage에 토큰을 저장합니다.

React 라우팅: App.tsx에서 useEffect를 통해 로컬 스토리지에 토큰이 있는지 확인하고, 있다면 LoginPage를 건너뛰고 바로 ChatRoomPage를 렌더링합니다.

추가사항
1. 기획서 기반 프로젝트 구조 생성
"방금 작성한 NaTalk.md 기획서를 읽고, 1인 개발자가 관리하기 편한 Express + React + Socket.io 프로젝트 구조를 만들어줘. 3002번 포트를 사용하도록 설정해줘."

2. 소켓 보안 로직 작성 (가장 중요)
"방장이 생성한 초대 코드와 비밀번호를 가진 사람만 Socket.io 룸에 접속할 수 있는 미들웨어 로직을 Node.js로 작성해줘. 10명 제한 기능도 포함해줘."

3. PWA 자동 로그인 최적화
"사용자가 한 번 입장하면 localStorage에 토큰을 저장하고, 앱 재진입 시 자동으로 대화방에 연결되는 React Custom Hook을 만들어줘."

*디자인 
'카톡 스타일' 디자인 가이드
에이전트에게 채팅창 UI 코드를 요청할 때 이렇게 덧붙여 보세요:

배경색: "배경은 카톡 특유의 **연한 푸른색(#ABC1D1)**으로 설정해줘."

말풍선: "내가 보낸 메시지는 노란색(#FEE500) 말풍선에 오른쪽 배치, 상대방 메시지는 흰색 말풍선에 왼쪽 배치해줘."

둥근 모서리: "말풍선 모서리는 둥글게 하되, 꼬리 부분이 살짝 튀어나온 느낌을 Tailwind CSS의 rounded 속성으로 구현해줘."

입력창: "하단 입력창은 흰색 배경에 고정(fixed)시키고, 전송 버튼은 노란색이나 파란색 아이콘으로 만들어줘."

시간 표시: "메시지 옆에 아주 작은 글씨로 오전/오후 00:00 형식의 시간을 넣어줘."

##7 방생성
1. 방 생성 시 필요한 데이터 (Data Schema)
서버의 chats.json이나 DB에 저장될 때, 최소한 이 정보들이 있어야 합니다.

roomId: 랜덤하게 생성된 고유 문자열 (예: vibe-7nd2-89sf)

roomPassword: 방장이 설정한 입장 암호

ownerId: 방장의 아이디 (또는 기기 고유값)

maxUsers: 10명 제한 (기획서 내용 반영)

createdAt: 생성 날짜
2. 서버 측 구현 (Node.js + Socket.io)
방 생성을 위해 서버에 추가해야 할 로직입니다. Gemini 에이전트에게 이렇게 요청해 보세요.

"Socket.io를 사용해서 새로운 대화방을 생성하는 API를 만들어줘. 방 생성 시 고유한 Room ID가 생성되어야 하고, 방장이 설정한 비밀번호를 서버에 저장해야 해. 그리고 방 생성자는 자동으로 해당 방의 관리자 권한을 가져야 해."
3. 클라이언트 구현  
방장이 앱을 켜고 처음 마주할 [방 생성 화면] 구성 요소입니다.

방 이름 입력: (예: "바이브코딩 전략회의실")

입장 암호 설정: (기획서의 '암호로 승인' 기능)

방 생성 버튼: 클릭 시 서버로 데이터를 보내고 roomId를 받아옴.

초대 코드 복사: 생성된 roomId를 친구에게 공유할 수 있는 기능.
방 이름이 겹치지 않게 하려면 uuid 라이브러리를 쓰거나, 간단하게 아래 같은 함수를 쓸 수 있습니다. (Gemini에게 짜달라고 하면 바로 해줍니다.)

##7 수정된 기획 내용  
수익 모델: 방 생성 시 월 구독료 10,000원 결제 필요.
결제 방식: QR코드(카카오페이, 토스, 혹은 네이버페이) 송금/결제 연동.
프로세스:
사용자가 '방 생성' 클릭.
결제용 QR코드가 화면에 노출.
결제 완료 확인(방장이 승인하거나 API 연동).
결제 확인 후 고유 Room ID와 암호 설정 활성화.
2. 현실적인 QR 결제 구현 방법 (1인 개발자용)
정식 결제 PG사(나이스페이 등)를 연동하면 심사가 까다롭고 복잡합니다. 초기 단계에서는 다음과 같은 방식을 추천드립니다.

방법 A: 고정 금액 송금 QR (가장 간편)
방식: 카카오페이/토스의 '내 송금 QR' 이미지를 앱에 띄워줍니다.

확인: 사용자가 입금 후 '입금 완료' 버튼을 누르면, 방장(대표님)에게 알림이 가고 대표님이 관리자 페이지에서 승인해주는 방식입니다. (10명 미만 소규모라면 충분히 수동 관리가 가능합니다.)

3. 기술적 로직 흐름 (Sequence)
Gemini 에이전트에게 코드를 요청할 때 이 흐름을 참고하세요:

Client: 방 생성 버튼 클릭 -> 서버에 request_payment 요청.

Server: 결제용 QR 이미지 경로와 payment_id를 응답.

Client: QR 이미지를 모달(Modal)로 띄우고 사용자가 스캔하게 함.

Admin(대표님): 입금 확인 후 서버에서 해당 payment_id를 approved 상태로 변경.

Client: 상태 확인(Polling) 후 방 설정 화면으로 자동 전환.


client/src/components/CreateRoom.tsx 파일에 결제용 QR 이미지를 보여주는 모달 기능을 추가해줘.

결제가 완료되었다는 신호를 서버에서 받기 전까지는 방 생성 폼(ID, PW 설정)으로 넘어가지 못하게 막아줘.

서버(server/index.js)에는 결제 상태를 관리하는 간단한 로직을 넣어줘."

💡 대표님을 위한 팁
처음에는 카카오페이 송금 QR을 이미지 파일로 public 폴더에 넣고, 유저가 송금한 뒤 "입금 확인 요청" 버튼을 누르면 대표님 메일이나 카톡으로 알림이 오게끔만 해도 충분히 '유료 서비스'의 느낌을 낼 수 있습니다.

*설명은 할글로 해줘.